#!/usr/bin/python3
# -*- mode: python; python-shell-interpreter: "python3"; -*-

import os
import subprocess
from sys import argv

diff = "diff"
dot = "dot"
pl241c = "/home/brian/Code/cs241/pl241c"
test_dir = "/home/brian/Code/cs241/test/"
input_dir = test_dir + "input/"
output_dir = test_dir + "output/"
result_dir = test_dir + "results/"

# run the arguments as a subprocess, with output redirected to
# /dev/null, return true if the subprocess returns 0, otherwise return
# false.
def run_no_output(args):
    null = open("/dev/null")
    proc = subprocess.Popen(args, stdout = null, stderr = null)
    ret = proc.wait()
    return ret == 0;

# returns true on success (files match) false on error
def run_diff(file1, file2):
    return run_no_output([diff, file1, file2]);

def run_dot(in_file):
    png_out = strip_file_extension(in_file) + ".svg"
    return run_no_output([dot, "-Tsvg", in_file, "-o", png_out])

# you can specify extra compilation options if the first line of the
# file starts with '#%'. After that marker, the remaining contents of
# the first line will be sent to the compiler as extra options
def compile_pl241(in_file, out_file):
    extra_args = []
    fin = open(in_file)
    first = fin.readline()
    fin.close()
    if(first[:2] == '#%'):
        extra_args = first[2:].split(sep=" ")
    return run_no_output([pl241c, in_file, "-cfg", out_file] + extra_args)

def strip_file_extension(name):
    return os.path.splitext(name)[0]

def file_extension(name):
    return os.path.splitext(name)[1]

def is_test(name):
    return file_extension(name) == '.txt'

# this will return an error string if the test failed, otherwise it
# will return false. This is different than the convention I am using
# for all of my other command running functions, but it makes things easy.
def run_test(name):
    infile = input_dir + name + ".txt"
    out_ref = output_dir + name + ".gv"
    result_file = result_dir + name + ".gv"
    print("Running test ", name, ".. ", sep="", end="")
    if(not compile_pl241(infile, result_file)):
        outmsg = "Compilation error"
        print("FAIL", outmsg)
        return outmsg
    if(not run_dot(result_file)):
        outmsg = ".gv -> .png layout failed"
        print("FAIL", outmsg)
        return outmsg
    if(not run_diff(out_ref, result_file)):
        outmsg = "Output incorrect"
        print("FAIL", outmsg)
        return outmsg
    print("PASS")
    return False

# use this to generate the reference output once you are confident in
# your compiler
def generate_ref_out(name):
    infile = input_dir + name + ".txt"
    out_file = output_dir + name + ".gv"
    print("Generating reference output for ", name, ".. ", sep="", end="")
    if(not compile_pl241(infile, out_file)):
       print("ERROR Compilation error")
    print("DONE")

if __name__ == "__main__":
    # if there are no command line arguments, run all tests
    if(len(argv) == 1):
        tests = sorted(map(strip_file_extension,
                           filter(is_test, os.listdir(input_dir))))
    else:
        tests = []
        i = 1
        while i < len(argv):
            a = argv[i]
            if a == "-ref":
                i += 1
                generate_ref_out(argv[i])
            else:
                tests.append(a)
            i += 1

    if(tests):
        if(not os.path.isdir(result_dir)):
            os.mkdir(result_dir)
        failures = []
        print("Starting tests\n")
        for t in tests:
            s = run_test(t)
            if(s):
                failures.append(t + ": " + s)
        if(failures):
            print("\nError the following tests have failed:\n")
            for s in failures:
                print(s)
        else:
            print("\nAll tests passed!")




